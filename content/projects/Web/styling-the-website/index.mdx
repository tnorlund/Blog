---
title: Styling The Website
slug: /projects/web/styling-the-website
date: "2020-09-28T11:16:00"
description: "I added styled-components! With this comes React Hooks, ways to store data locally, and much more."
showToc: true
---

import DarkToggle from 'components/DarkToggle'
import { BorderBox } from 'components/styles'

Previously, this blog was pretty boring. It definitely needed some sprucing up.

So I decided to add [styled components](https://styled-components.com) and react hooks. These together, add color and shape most of the website.

# React Hooks

Making this website has shown me just how extensive React is. React uses "states" to render different components. This allows for some really cool stuff!

## Event Listeners

The first Hook implemented was the table of contents. As you scroll through the page, the ToC knows where you are on the page. It can change which heading is *active* because it knows how far you've scrolled through the page. 

## Querying Media

Hooks allow us to change the page on the fly. Different sized screens require different styling. Styled-components allow for the content and styling to be written one time while the properties of the window can result in different styles to be queried. Below are the different sizes.

```js:title=src/utils/mediaQueries.js
const min = width => `only screen and (min-width: ${width}em)`
const max = width => `only screen and (max-width: ${width}em)`

export const screens = {
  phone: 30,
  phablet: 40,
  tablet: 50,
  netbook: 60,
  laptop: 70,
  desktop: 100,
}

export const mediaQueries = Object.entries( screens ).reduce(
  ( acc, [key, val] ) => {
    const Key = key[0].toUpperCase() + key.substr( 1 )
    acc[`min` + Key] = `@media ` + min( val )
    acc[`max` + Key] = `@media ` + max( val )
    acc[`min` + Key + `Js`] = min( val )
    acc[`max` + Key + `Js`] = max( val )
    return acc
  }, {}
)
```

A React Hook can be used to query these values.

```js:title=src/hooks/useMediaQuery.js
import { useEffect, useState } from 'react'
import { mediaQueries } from 'utils/mediaQueries'

export const useMediaQuery = ( query, cb ) => {
  const [matches, setMatches] = useState( false )

  useEffect( () => {
    const qry = window.matchMedia( query )
    setMatches( qry.matches )
    const handleMatch = q => {
      setMatches( q.matches )
      if ( cb instanceof Function ) cb( q.matches )
    }

    qry.addListener( handleMatch )
    return () => qry.removeListener( handleMatch )
  }, [query, cb] )

  return matches
}

const validKeys = Object.keys( mediaQueries ).filter(
  key => !key.includes( `Js` )
)

export const useScreenQuery = ( key, cb ) => {
  if ( !mediaQueries[key + `Js`] )
    throw new TypeError(
      `useScreenQuery received an invalid key: ${key}.`
      + ` Should be one of ${validKeys}`
    )
  return useMediaQuery( mediaQueries[key + `Js`], cb )
}
```

This allows us to query the preferred style based on the size of the screen. If you're on a desktop, try resizing the window to see the webpage change. This is useful because it handles mobile screens.

## Storing Locally

In order to remember user preferences between visits, the page needs to store information locally. Luckily, React Hooks allow to store data to the window and access it later.

The first step in doing this is writing the data to the window. Bellow, the values are stored and an `eventListener` is added.

```js:title=src/hooks/useStorage.js
...
useEffect( () => {
  if ( storage[key] === undefined )
    storage[key] = JSON.stringify( value )

  const cb = event => setValue( event.detail )
  document.addEventListener( `storage:${key}Change`, cb )
  return () => document.removeEventListener(
    `storage:${key}Change`, cb 
  )
}, [value, key, storage] )
...
```

Once the `eventListener` is created, the event can then be triggered.

```js:title=src/hooks/useStorage.js
...
const setStoredValue = newValue => {
  if ( newValue === value ) return
  if ( newValue instanceof Function ) 
    newValue = newValue( value )

  const event = new CustomEvent( 
    `storage:${key}Change`, 
    { detail: newValue } 
  )
  document.dispatchEvent( event )

  if ( newValue === deleteKeyIfValueIs )
    delete storage[key]
  else storage[key] = JSON.stringify( newValue )

  setValue( newValue )
}
...
```

# Dark Mode

As a programmer, *EVERYTHING* is darkmode. With the help of [Janosh Riebesell](https://github.com/janosh/blog), I started implementing some different styling techniques.

This React Hook relies on
- `localStorage` to save user preference
- a custom event bus for multiple call sites to `useDarkMode`
- styled-components for both the darkmode and non-darkmode

The React Hook responsible for this is responsible for setting the styled-components based on `MODE_COLORS`.

```js:title=src/hooks/useDarkMode.js
...
const setBodyColors = mode => {
  for ( 
    const [name, colorByMode] of Object.entries( MODE_COLORS )
  ) {
    document.body.style.setProperty( 
      `--color-${name}`, colorByMode[mode] 
    )
  }
}
...
```

After setting the colors, the Hook is really easy. MacOS and iOS have the option of *preferring* a mode. This is accomplished by querying the media the OS sets. After setting the initial state, the hook can set the colors.

```js:title=src/hooks/useDarkMode.js
...
export const useDarkMode = () => {
  const [
    colorMode, setLSColorMode
  ] = useLocalStorage( COLOR_MODE_KEY )

  const prefersDarkFromMQ = useMediaQuery(
    `(prefers-color-scheme: dark)`,
    useCallback(
      prefersDark => setBodyColors( 
        prefersDark ? `dark` : `light` 
      ), []
    )
  )

  useEffect( () => {
    const initialColorMode = 
      document.body.style.getPropertyValue(
        INITIAL_COLOR_MODE_CSS_PROP
      )
    setLSColorMode( initialColorMode )
  }, [] )

  function setColorMode( newValue ) {
    setLSColorMode( newValue )
    if ( newValue === `osPref` ) {
      newValue = prefersDarkFromMQ ? `dark` : `light`
    }
    setBodyColors( newValue )
  }
  return [colorMode, setColorMode]
}
...
```

Below is a button that calls the darkmode hook.

<BorderBox><DarkToggle /></BorderBox>
