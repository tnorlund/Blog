---
title: Adding A Back End
slug: /projects/web/adding-a-back-end
date: "2020-10-26T11:38:53"
description: "I added a way to login, follow projects, and comment on posts using Amplify."
showToc: true
---

import MdxIcon from 'components/MdxIcon'

After playing around with the Amplify command-line interface, I felt like I had the chops to add some more interactivity to this website. After a good week of learning the Amplify and AWS SDK, I was able to assemble something that's:
- scalable
- fast
- *relatively* cheap

Amplify combines [Cognito](https://aws.amazon.com/cognito/), [API Gateway](https://aws.amazon.com/api-gateway/), and [DynamoDB](https://aws.amazon.com/dynamodb/), which allows developers to quickly ship a product. This was a great way to jump headfirst into the AWS ecosystem.

I've had experience using a few different relational databases, but DynamoDB is nothing close to what I've previously used. DynamoDB is a "key-value and document database that delivers single-digit millisecond performance at any scale." I decided to dive deeper into DynamoDB by picking up [Alex DeBrie's](https://twitter.com/alexbdebrie?s=21) book. After a lot of reading and testing, I was able to create a database that is easily accessible by the API created by Amplify.

# Signing In

Amplify uses Cognito for their authentication, so I ended up using Cognito. It gets expensive with a larger user-base, but we'll see where this goes.

![Cognito](./AWSLogos_Cognito.svg)

Cognito handles the authentication and segments users based on the roles given to them. By using Cognito User Groups, I'm able to assign specific people 'Admin' access to the API. This allows me to change the website by using an API that only I have permission to use.

# Creating the Database

Again, I've had no experience with DynamoDB. This book helped me tremendously, and after purchasing the book, you're invited to a group of other DynamoDB developers. 

![DynamoDB](./AWSLogos_DynamoDB.svg)

DeBrie has an organized system for creating a Dynamo DB table.

1. [Understand the application](#understanding-the-application)
2. [Create an ERD](#erd)
3. [Define the access patterns](#access-patterns)
4. [Design the primary keys and secondary indexes](#primary-key-and-indexes)

## Understanding the application

This blog is accessed by people and the goal is to add comments for each post. Without getting "in the weeds" with the complexity of the problem, let's leave it at this.

 Each post will need to request the different comments, and each user will need to have the opportunity to add a comment to each post. Each user should be able to request all of their comments and delete a specific one.

## ERD

The entity relationship diagram describes how the datas relate to one another. The one that I came up with is as follows. 

<MdxIcon filename={`ERD.svg`}/>

## Access Patterns 

The best way to go about the understanding the access patterns would be to list them by entity. These accesses are either creating something, reading something, updating something, or deleting something. Amplify sets up an API Gateway that allows you to define your access patterns and the permissions required for each.

![API Gateway](./AWSLogos_APIGateway.svg)

I decided to separate the patterns into the 3 main entities seen in the ERD above. 

**User**
- Create a user
- Accept a terms of service
- Check to see if the latest terms of service has been accepted
- View followed projects per user
- View comments per user

**Projects**
- Follow a project
- Get all users that follow a project

**Post**
- Users can create, update, and delete their comment
- View comments and their replies per post

These alone don't mean much, but they help when deciding the primary keys and sort keys.

## Primary Key and Indexes

DynamoDB uses a single table to organize all the data. This means that the relationships, sorting, and access patterns use a combination of the partition key, *PK*, and the sort key, *SK*, to access the data. Both the *PK* and *SK* are used to access the specific row requested from the table. 

Amplify also creates a Lambda function when it creates the API Gateway. This Lambda function is what contains the logic for each access pattern found in API Gateway.

![Lambda](./AWSLogos_Lambda.svg)

I found the best way to implement both the *PK* and *SK* was to create them while implementing the Lambda function.

### User

The user needs to be accessible by a unique identifier. This unique identifier ended up being one more than the number of current users. In order to ensure that DynamoDB handles the sorting correctly, the numbers are zero-padded.

|                  | PK                 | SK                             |
|------------------|--------------------|--------------------------------|
| User             | USER#[User Number] | #USER                          |
| Terms Of Service | USER#[User Number] | #TOS#[Terms Of Service Number] |

The backend code is simplified by storing the entities in the `/entities` folder and the data accesses patterns in the `/data` folder. Here's an example of the user entity.

```js:title=entities/user.js
class User {
  constructor( { 
    name, email, userNumber = `0`, 
    dateJoined = new Date(), numberTOS = `0` 
  } ) {
    if ( !name )
      throw Error( `Must give the user's name` )
    this.name = name
    if ( !email )
      throw Error( `Must give the user's email` )
    this.email = email
    this.userNumber = parseInt( userNumber )
    this.dateJoined = dateJoined
    this.numberTOS = parseInt( numberTOS )
    this.numberFollows = parseInt( numberFollows )
  }

  pk() {
    return { 'S': `USER#${
      ( `00000` + this.userNumber ).slice( -6 )
    }` }
  }

  key() {
    return {
      'PK': { 'S': `USER#${
        ( `00000` + this.userNumber ).slice( -6 )
      }` },
      'SK': { 'S': `#USER` }
    }
  }

  toItem() {
    return {
      ...this.key(),
      'Type': { 'S': `user` },
      'Name': { 'S': this.name },
      'Email': { 'S': this.email },
      'DateJoined': { 'S': this.dateJoined.toISOString() },
      'NumberTOS': { 'N': this.numberTOS.toString() },
      'NumberFollows': { 'N': this.numberFollows.toString() }
    }
  }
}

const userFromItem = ( item ) => {
  return new User( {
    name: item.Name.S,
    email: item.Email.S,
    userNumber: item.PK.S.split( `#` )[1],
    dateJoined: item.DateJoined.S,
    numberTOS: item.NumberTOS.N
  } )
}

module.exports = { User, userFromItem }
```

While the terms of service can be updated at any time, the website must compare the current Terms of Service to the last one accepted by the user, if any exists to begin with. I ended up using a `getUserDetails` module to easily access the user and the Terms of Service previously agreed to.

```js:title=data/getUserDetails.js
const getUserDetails = async ( tableName, user ) => {
  if ( !tableName ) throw Error(
    `Must give the name of the DynamoDB table` 
  )
  try {
    const result = await dynamoDB.query( {
      TableName: tableName,
      KeyConditionExpression: `#pk = :pk`,
      ExpressionAttributeNames: { '#pk': `PK` },
      ExpressionAttributeValues: { ':pk': user.pk() }
    } ).promise()
    if ( !result.Items ) return {
      error: `User does not exist`
    }
    return { user: result.Items.map( ( item ) => {
      switch ( item.Type.S ) {
        case `user`: return userFromItem( item )
        case `terms of service`: return tosFromItem( item )
        default: 
          throw Error(
            `Could not parse type ${item.Type.S}`
          )
      }
    } ) }
  } catch( error ) {
    console.log( `Failed to get user`, error )
    return { error: `Could not get user` }
  }
}

module.exports = { getUserDetails }
```

Now the user and their details are accessible through the client. You can create an account by clicking in the top right corner.

### Project

Each project is uniquely identified with the slug associated to it. The project's followers need to be queried while the projects the user follows must be queried too. Luckily, DynamoDB has Global Secondary Indexes that allow for different querying methods. The *PK* and *SK* are used to query the user's follows.

|                  | PK                     | SK                            |
|------------------|------------------------|-------------------------------|
| Project          | #PROJECT               | PROJECT#[Project Slug]        |
| Project Follow   | USER#[User Number]     | #PROJECT#[User Follow Number] |

The user can request their details by querying a partition key `USER#[User Number]` with a response of their data, the Terms of Services agreed to, and the projects they follow. The Global Secondary Indexes are use to query the project's followers.

|                  | GSI1PK                 | GSI1SK                           |
|------------------|------------------------|----------------------------------|
| Project          | PROJECT#[Project Slug] | PROJECT#[Project Slug]           |
| Project Follow   | PROJECT#[Project Slug] | #PROJECT#[Project Follow Number] |

The project and the project's followers are queried by the Global Secondary Index's partition key, *GSI1PK*. These different indexing methods allow DynamoDB to remain simple and efficient.

### Comments

The comments are requested by both the user and the post:
- Get all of the user's comments
- Get all comments per post

Both of these access patterns are achieved by multiple primary keys. This first uses *PK* and *SK* to request all of the comments the user has made.

|         | PK                 | SK                             |
|---------|--------------------|--------------------------------|
| Post    | POST#[Post Slug]   | #POST                          |
| Comment | USER#[User Number] | #COMMENT#[User Comment Number] |
| Vote    | USER#[User Number] | #COMMENT#[User Vote Number]    |

The Global Secondary Index is used to query the all of the comments per post.

|         | GSI1PK           | GSI1SK                                       |
|---------|------------------|----------------------------------------------|
| Post    | POST#[Post Slug] | #POST                                        |
| Comment | POST#[Post Slug] | #COMMENT#[Post Comment Number]               |
| Vote    | POST#[Post Slug] | #COMMENT#[Post Comment Number]#[Vote Number] |

# Analytics

After adding all of this, I'd like to understand how people interact with it. Amplify makes analytics really easy by integrating Kinesis.

![Kinesis](./AWSLogos_Kinesis.svg)

Kinesis records when someone visits the website, clicks on button, and much more. There's not that much to share yet, because I haven't recorded that much. 

# Conclusion

This was a lot of work. I know that I had the option to use [Disqus](https://disqus.com), but it's \$100 a year. This costs maybe \$0.10 a month, and it can scale to hundreds of dollars a year.

I was able to pick up a large portion of the services AWS has to offer while also learning how to optimize and construct DynamoDB tables.